#include "minunit.h"

#include "get_quat_from_K.h"
#include "get_quat_from_K_initialize.h"
#include "get_quat_from_K_terminate.h"
#include "optimal_request.h"
#include "optimal_request_init.h"

// This is generated by {root_dir}/matlab/tests/gen_meas_for_c.m
#include "test_meas_data.h"	

#include "helper.h"


// should be the same as in the 'test_OR_rms_error.m' Matlab script
#define MAX_RMS_ERROR_THRESHOLD (4.0) // degrees


void test_setup(void) {
	get_quat_from_K_initialize();
}

void test_teardown(void) {
	get_quat_from_K_terminate();
}

void or_fill_r(float r[6], float vec1[3], float vec2[3])
{
	r[0] = vec1[0];
	r[1] = vec1[1];
	r[2] = vec1[2];
	r[3] = vec2[0];
	r[4] = vec2[1];
	r[5] = vec2[2];
}

void or_fill_b(float b[6], float vec1[3], float vec2[3])
{
	b[0] = vec1[0];
	b[1] = vec1[1];
	b[2] = vec1[2];
	b[3] = vec2[0];
	b[4] = vec2[1];
	b[5] = vec2[2];
}

void or_fill_w(float w[3], float vec_w[3])
{
	w[0] = vec_w[0];
	w[1] = vec_w[1];
	w[2] = vec_w[2];
}

MU_TEST(test_run_optimal_request) {
	float q_est[4];
	float euler_est[3], euler_gt[3];
	float rms_errors[TEST_MEAS_DATA_MEAS_LEN];
	struct0_T or_handle;

	// these values are not changing
	or_handle.Mu_noise_var = TEST_MEAS_DATA_MU_NOISE_VAR;
	or_handle.Eta_noise_var = TEST_MEAS_DATA_ETA_NOISE_VAR;
	or_handle.dT = TEST_MEAS_DATA_DT;

	// first measurements
	or_fill_r(or_handle.r, test_meas_data_ref_acc[0], test_meas_data_ref_mag[0]);
	or_fill_b(or_handle.b, test_meas_data_bdy_acc[0], test_meas_data_bdy_mag[0]);
	or_fill_w(or_handle.w, test_meas_data_bdy_gyr[0]);

	// init optimal_req on 1st meas
	optimal_request_init(&or_handle);

	// get q from K
	get_quat_from_K(or_handle.K, q_est);
	// convert q to Eulers
	get_euler_from_q(euler_est, q_est);

	// convert rad to deg
	rad2deg(euler_est, euler_est, 3);
	rad2deg(euler_gt, test_meas_data_euler_gt[0], 3);

	// calculate rms error
	rms_errors[0] = euler_rms_error(euler_est, euler_gt);

	for (int i=1; i<TEST_MEAS_DATA_MEAS_LEN; i++) {
		// fill r and b vectors with measurements
		or_fill_r(or_handle.r, test_meas_data_ref_acc[i], test_meas_data_ref_mag[i]);
		or_fill_b(or_handle.b, test_meas_data_bdy_acc[i], test_meas_data_bdy_mag[i]);
		or_fill_w(or_handle.w, test_meas_data_bdy_gyr[i]);

		// call optimal req on meas
		optimal_request(&or_handle);

		// get q from K
		get_quat_from_K(or_handle.K, q_est);

		// convert q to Eulers
		get_euler_from_q(euler_est, q_est);

		// convert rad to deg
		rad2deg(euler_est, euler_est, 3);
		rad2deg(euler_gt, test_meas_data_euler_gt[i], 3);

		// calculate rms error
		rms_errors[i] = euler_rms_error(euler_est, euler_gt);
	}

	// check if cum rms error is within some threshold
	float rms_error_mean, rms_error_std;
	mean_std(&rms_error_mean, &rms_error_std, rms_errors, TEST_MEAS_DATA_MEAS_LEN);
	printf("C: rms_error_mean = %f [deg]\n", rms_error_mean);
	printf("C: rms_error_std  = %f [deg]\n", rms_error_std);

	float max_rms_error = rms_error_mean + 3.0f * rms_error_std;

	mu_check(max_rms_error < MAX_RMS_ERROR_THRESHOLD);
}

MU_TEST_SUITE(test_suite) {
    MU_RUN_TEST(test_run_optimal_request);
}

int main(int argc, char *argv[]) {

	(void)argc;
	(void)argv;
	
	MU_RUN_SUITE(test_suite);
	MU_REPORT();
    
	return MU_EXIT_CODE;
}
