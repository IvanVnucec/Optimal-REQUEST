%% Program cita autogenerirana mjerenja i izracunava kvaternion
clear all;
close all;
clc;

% -------------------------------------------------------------------------
% Deklaracija i inicijalizacija varijabli
% -------------------------------------------------------------------------

% Maksimalna dopustiva razlika u gresci
delta_max = 1e-4;
% Maksimalni dopustivi broj iteracija
N_max = 20;
% Learning rate
alpha = 0.1;
% Tezinski faktor komplementarnog filtra
K_CF = 0.95;

% Max noise amplitude in acc, mag & gyro measurements
a_noise = 3e-2;
m_noise = 1e-1;
g_noise = 3e-2;
% Gyro bias
bias = 1e-2;



% Inicijalni kvaternion
q_init = [1,1,1,1]';
q_init = q_init/norm(q_init);
% Zastavica za prvi uzorak u komplementarnom filtru
first_flag = true;
% Frekvencija uzorkovanja u Hz;
fs = 10;
% Vrijeme uzorkovanja
delta_t = 1/fs;


% -------------------------------------------------------------------------
% Ucitavanje datoteke s generiranim mjerenjima
% -------------------------------------------------------------------------

filename = 'Autogenerated_measurements_x.csv';
data_from_file = importdata(filename);

data_from_file = struct2cell(data_from_file);
data    = data_from_file{1};
header  = data_from_file{2};

[N_row, N_col] = size(data);



% -------------------------------------------------------------------------
% Kreiranje matrice referentnih vektora I
% -------------------------------------------------------------------------

a_i = data(1,1:3)'; % Referena akceleracija u inercijalnom sustavu
m_i = data(1,4:6)'; % Referentno magnetsko polje u inercijalnom sustavu
a_i = a_i/norm(a_i); % Normaliziram akceleraciju
m_i = m_i/norm(m_i); % Normaliziram mag polje

I = [a_i,m_i];  % Normalizirane vektore spremam u matricu I (ona se ne mijenja)

% Priprema vektora greske i broja iteracija
NOI_vect = zeros(1, N_row);
error_vect = zeros(1, N_row);
error_angle = zeros(1, N_row);
angle_gt = zeros(1, N_row);
angle_est = zeros(1, N_row);

% -------------------------------------------------------------------------
% Vrtim mjerenja u petlji
% -------------------------------------------------------------------------
for n = 1:N_row
    
    a_b = data(n,10:12)'; % Akceleracija u sustavu tijela
    m_b = data(n,13:15)'; % Magnetsko polje u sustavu tijela
    
    a_b = a_b/norm(a_b); % Normaliziram akceleraciju
    m_b = m_b/norm(m_b); % Normaliziram mag polje
    
    % Sum dodajem na normalizirana mjerenja pa nakon toga opet normaliziram
    % Na taj nacin lakse mogu zadati amplitidu suma
    a_b = a_b + a_noise*(2*rand(3,1)-1); % Dodajem sum akceleraciji
    m_b = m_b + m_noise*(2*rand(3,1)-1); % Dodajem sum magnetskom polju
    
    a_b = a_b/norm(a_b); % Normaliziram akceleraciju
    m_b = m_b/norm(m_b); % Normaliziram mag polje
    
    B = [a_b,m_b]; % Spremam akceleraciju i mag polje u matricu

    
    % Kutna brzina u sustavu tijela
    w_b = data(n,16:18)';
    w_b = w_b + g_noise*(2*rand(3,1)-1) + bias; % Dodajem sum i bias
    
    
    
    % ---------------------------------------------------------------------
    % Kod komplementarnog filtra
    % ---------------------------------------------------------------------
    
    % Calculating optimal quaternion in iterative proces
    [qib_gd, NOI, J] = iquest(I, B, q_init, delta_max, alpha, N_max);
    
    % U prvom koraku orijentaciju odredjujemo samo iz acc i mag
    if first_flag == true
        qib_est = qib_gd;
        first_flag = false;
    
    % U svakom sljedecem koraku orijentaciju odredjujemo iz acc, mag i gyro
    else
        % Calculating quaternion time derivative from gyroscope measurement
        S_w = [0     , -w_b(1), -w_b(2), -w_b(3);
               w_b(1),  0     ,  w_b(3), -w_b(2);
               w_b(2), -w_b(3),  0     ,  w_b(1);
               w_b(3),  w_b(2), -w_b(1),  0];  
        d_qib_dt = 0.5*S_w*qib_prev;
        
        % Integratition (accumulation) to get current quaternion from gyro        
        qib_gyro = delta_t*d_qib_dt + qib_prev;
        
        % Estimating quaternion from qib_gd and qib_gyro
        % Complementary filter gain sets the weight of each estimation
        qib_est = (1-K_CF)*qib_gd + K_CF*qib_gyro;
        
        % Normalization of the estimated quaternion (just in case)
        qib_est = qib_est/norm(qib_est);
    end
    
    % Ispis broja iteracija za trenutni proces i spremanje u vektor
    disp(NOI);
    NOI_vect(n) = NOI;
    
    % Storing current quaternion for the next iterative process
    q_init = qib_est;
    qib_prev = qib_est;
    
    % Mjera slicnosti poznatog i procijenjenog kvaterniona
    qib_gt = data(n,19:22)'; % Ground thruth quaternion
    qib_est_conj = [qib_est(1); -qib_est(2:4)];
    qib_error = [1,0,0,0]' - quatMul(qib_gt, qib_est_conj);
    
    % Mogu se definirati razlicite mjere greske (odabrana se sprema u error_vect)
    sqared_error = qib_error'*qib_error;
    norm_error = norm(qib_error);
    q1_error = qib_error(1);
    
    error_vect(n) = q1_error;
    
    
    

    
    % More details: Full Quaternion Based Attitude Control for a Quadrotor
    % by Emil Fresk and George Nikolakopoulos
    
    % Kratko objasnjenje: Ako je kvaternion dobro procijenjen, tada umnozak
    % qib_gt i konjukiranog procijenjenog kvaterniona quib_est daje [1 0 0 0]'.
    % Drugim rijecima, prvi kvaternion umnoska rotira u jednu strana, a
    % drugi kvaternion vraca u pocetni polozaj ([1 0 0 0]' je neutralni
    % kvaternion koji ne rotira vektor). U realnom slucaju, dobit ce se
    % neki drugi vektor ciji se elementi razlikuju od [1 0 0 0]'. Buduci da
    % je u idealnom slucaju suma kvadrata elemenata kvaterniona 1, tada
    % gresku racunamo kao 1 minus suma kvadrata elemenata (ili skalarni
    % umnozak vektora rezultantnog kvaterniona sa samim sobom.
    
    angle_est(n) = rad2deg(2*atan2(norm(qib_est(2:4)), qib_est(1)));
    angle_gt(n) = rad2deg(2*atan2(norm(qib_gt(2:4)), qib_gt(1)));
    error_angle(n) = angle_gt(n) - angle_est(n);

    
    
    % ---------------------------------------------------------------------
    % Crtanja rotirajuceg objekta
    % ---------------------------------------------------------------------
    
    drawPlane(qib_est);  
    drawnow;
    
end

% Time base
t = linspace(0, N_row*delta_t, N_row);

figure;
subplot(3,1,1);
plot(t, NOI_vect);
ylim([0,N_max]);
grid on;
xlabel('Time [s]');
ylabel('Number of iterations');


subplot(3,1,2);
semilogy(t, abs(error_vect));
ylim([1e-5,1e0]);
grid on;
xlabel('Time [s]');
ylabel('Error');


subplot(3,1,3);
plot(t, abs(error_angle));
grid on;
xlabel('Time [s]');
ylabel('Error angle [deg]');

figure;
plot(t, angle_gt, t, angle_est);
grid on;
xlabel('Time [s]');
ylabel('Angle [deg]');
title('Ground thruth and estimated angle');